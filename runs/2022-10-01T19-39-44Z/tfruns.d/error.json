{
  "message": "ValueError: in user code:\n\n    File \"C:\\Users\\ygong\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\keras\\engine\\training.py\", line 1021, in train_function  *\n        return step_function(self, iterator)\n    File \"C:\\Users\\ygong\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\keras\\engine\\training.py\", line 1010, in step_function  **\n        outputs = model.distribute_strategy.run(run_step, args=(data,))\n    File \"C:\\Users\\ygong\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\keras\\engine\\training.py\", line 1000, in run_step  **\n        outputs = model.train_step(data)\n    File \"C:\\Users\\ygong\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\keras\\engine\\training.py\", line 859, in train_step\n        y_pred = self(x, training=True)\n    File \"C:\\Users\\ygong\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\keras\\utils\\traceback_utils.py\", line 67, in error_handler\n        raise e.with_traceback(filtered_tb) from None\n    File \"C:\\Users\\ygong\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\keras\\engine\\input_spec.py\", line 264, in assert_input_compatibility\n        raise ValueError(f'Input {input_index} of layer \"{layer_name}\" is '\n\n    ValueError: Input 0 of layer \"sequential\" is incompatible with the layer: expected shape=(None, 234), found shape=(None, 300)\n",
  "traceback": ["py_call_impl(callable, dots$args, dots$keywords)", "(structure(function (...) \n{\n    dots <- py_resolve_dots(list(...))\n    result <- py_call_impl(callable, dots$args, dots$keywords)\n    if (convert) \n        result <- py_to_r(result)\n    if (is.null(result)) \n        invisible(result)\n    else result\n}, class = c(\"python.builtin.method\", \"python.builtin.object\"\n), py_object = <environment>))(batch_size = 256L, epochs = 50L, \n    verbose = 2L, validation_split = 0.2, shuffle = TRUE, class_weight = NULL, \n    sample_weight = NULL, initial_epoch = 0L, x = <environment>, \n    y = <environment>, callbacks = list(<environment>, <environment>, \n        <environment>, <environment>))", "do.call(object$fit, args)", "fit.keras.engine.training.Model(., x = train_data, y = train_labels, \n    epochs = 50, batch_size = 256, validation_split = 0.2, callbacks = list(callback_early_stopping(patience = 20), \n        callback_reduce_lr_on_plateau()), verbose = 2)", "fit(., x = train_data, y = train_labels, epochs = 50, batch_size = 256, \n    validation_split = 0.2, callbacks = list(callback_early_stopping(patience = 20), \n        callback_reduce_lr_on_plateau()), verbose = 2)", "keras_model_sequential() %>% layer_dense(units = FLAGS$nodes_layer1, \n    activation = \"relu\", input_shape = ncol(x)) %>% layer_batch_normalization() %>% \n    layer_dropout(rate = FLAGS$dropout_layer1) %>% layer_dense(units = FLAGS$nodes_layer2, \n    activation = \"relu\") %>% layer_batch_normalization() %>% \n    layer_dropout(rate = FLAGS$dropout_layer2) %>% layer_dense(units = FLAGS$nodes_layer3, \n    activation = \"relu\") %>% layer_batch_normalization() %>% \n    layer_dropout(rate = FLAGS$dropout_layer3) %>% layer_dense(units = 2, \n    activation = \"sigmoid\") %>% compile(loss = \"categorical_crossentropy\", \n    optimizer = optimizer_rmsprop(), metrics = \"auc\") %>% fit(x = train_data, \n    y = train_labels, epochs = 50, batch_size = 256, validation_split = 0.2, \n    callbacks = list(callback_early_stopping(patience = 20), \n        callback_reduce_lr_on_plateau()), verbose = 2)", "eval(ei, envir)", "eval(ei, envir)", "withVisible(eval(ei, envir))", "tuning_run(\"keras_grid_search.R\", flags = list(nodes_layer1 = c(64, \n    128, 256), nodes_layer2 = c(64, 128, 256), nodes_layer3 = c(64, \n    128, 256), dropout_layer1 = c(0.2, 0.3, 0.4), dropout_layer2 = c(0.2, \n    0.3, 0.4), dropout_layer3 = c(0.2, 0.3, 0.4)), confirm = FALSE, \n    echo = FALSE, sample = 0.01)"]
}
